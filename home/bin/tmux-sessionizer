#!/usr/bin/env zsh

# tmux-sessionizer - Fuzzy find and switch to project tmux sessions
# Enhanced with configuration system, stats tracking, and rich previews

# Configuration file location
CONFIG_FILE="${HOME}/.config/tmux-sessionizer/config"

# Default configuration values
SEARCH_PATHS=(
  "$HOME"
  "$HOME/personal"
  "$HOME/work"
  "$HOME/github"
  "$HOME/.homesick/repos/dotfiles/home"
)
MAX_DEPTH=1
ENABLE_PREVIEW=false
ENABLE_STATS=false
ENABLE_GIT_STATUS=false
ENABLE_TEMPLATES=false
STATS_FILE="${HOME}/.config/tmux-sessionizer/stats.json"
TEMPLATE_DIR="${HOME}/.config/tmux-sessionizer/templates"

# Load configuration file if it exists
if [[ -f "$CONFIG_FILE" ]]; then
  source "$CONFIG_FILE"
fi

# Stats management functions
load_stats() {
  if [[ -f "$STATS_FILE" ]]; then
    cat "$STATS_FILE"
  else
    echo "{}"
  fi
}

save_stats() {
  local stats="$1"
  echo "$stats" > "$STATS_FILE"
}

track_session_launch() {
  local session_path="$1"
  [[ "$ENABLE_STATS" != "true" ]] && return

  local stats=$(load_stats)
  local current_time=$(date +%s)
  local session_key=$(basename "$session_path")

  # Update or create stats entry using jq
  stats=$(echo "$stats" | jq --arg key "$session_key" \
                              --arg path "$session_path" \
                              --arg time "$current_time" \
    'if .[$key] then
      .[$key].count += 1 | .[$key].lastUsed = ($time | tonumber)
    else
      .[$key] = {path: $path, count: 1, lastUsed: ($time | tonumber)}
    end')

  save_stats "$stats"
}

calculate_frecency_score() {
  local count="$1"
  local last_used="$2"
  local current_time=$(date +%s)

  # Days since last use
  local days_diff=$(( (current_time - last_used) / 86400 ))

  # Recency weight: exponential decay
  # Recent (0-1 day): 1.0, 1-7 days: 0.8, 7-30 days: 0.5, 30+ days: 0.2
  local recency_weight=0.2
  if [[ $days_diff -le 1 ]]; then
    recency_weight=1.0
  elif [[ $days_diff -le 7 ]]; then
    recency_weight=0.8
  elif [[ $days_diff -le 30 ]]; then
    recency_weight=0.5
  fi

  # Frecency = (frequency * 0.5) + (recency * 50 * 0.5)
  # Scale recency component to be comparable to frequency
  local frecency=$(echo "$count * 0.5 + $recency_weight * 50 * 0.5" | bc -l)
  printf "%.2f" "$frecency"
}

format_last_used() {
  local last_used="$1"
  local current_time=$(date +%s)
  local diff=$((current_time - last_used))

  if [[ $diff -lt 3600 ]]; then
    local minutes=$((diff / 60))
    echo "${minutes}m ago"
  elif [[ $diff -lt 86400 ]]; then
    local hours=$((diff / 3600))
    echo "${hours}h ago"
  elif [[ $diff -lt 604800 ]]; then
    local days=$((diff / 86400))
    echo "${days}d ago"
  else
    local weeks=$((diff / 604800))
    echo "${weeks}w ago"
  fi
}

detect_project_type() {
  local dir="$1"

  # Check for specific project markers
  [[ -f "$dir/Cargo.toml" ]] && echo "rust" && return
  [[ -f "$dir/package.json" ]] && echo "nodejs" && return
  [[ -f "$dir/pyproject.toml" ]] || [[ -f "$dir/setup.py" ]] || [[ -f "$dir/requirements.txt" ]] && echo "python" && return
  [[ -f "$dir/go.mod" ]] && echo "go" && return
  [[ -d "$dir/.homesick" ]] && echo "dotfiles" && return
  [[ -f "$dir/Gemfile" ]] && echo "ruby" && return
  [[ -f "$dir/pom.xml" ]] || [[ -f "$dir/build.gradle" ]] && echo "java" && return

  # Check for .git with specific patterns
  if [[ -d "$dir/.git" ]]; then
    local remote=$(git -C "$dir" remote get-url origin 2>/dev/null)
    [[ "$remote" =~ dotfiles ]] && echo "dotfiles" && return
  fi

  echo "general"
}

get_project_type_icon() {
  local type="$1"

  case "$type" in
    rust)     echo "ü¶Ä" ;;
    nodejs)   echo "üì¶" ;;
    python)   echo "üêç" ;;
    go)       echo "üêπ" ;;
    dotfiles) echo "üè†" ;;
    ruby)     echo "üíé" ;;
    java)     echo "‚òï" ;;
    *)        echo "üíª" ;;
  esac
}

get_git_status() {
  local dir="$1"
  [[ "$ENABLE_GIT_STATUS" != "true" ]] && echo "" && return
  [[ ! -d "$dir/.git" ]] && echo "" && return

  cd "$dir" 2>/dev/null || return

  # Check if repo is clean
  if git diff-index --quiet HEAD -- 2>/dev/null; then
    # Clean repo, check if ahead/behind
    local ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null)
    local behind=$(git rev-list --count HEAD..@{u} 2>/dev/null)

    if [[ -n "$ahead" && "$ahead" -gt 0 ]] || [[ -n "$behind" && "$behind" -gt 0 ]]; then
      echo "~"  # Ahead or behind
    else
      echo "‚úì"  # Clean and in sync
    fi
  else
    echo "‚úó"  # Dirty (uncommitted changes)
  fi

  cd - >/dev/null 2>&1
}

get_git_status_icon() {
  local status="$1"
  [[ -z "$status" ]] && echo " " && return
  echo "$status"
}

build_directory_list_with_metadata() {
  local stats=$(load_stats)
  local directories=()

  # Find all directories
  local found_dirs=$((echo ${SEARCH_PATHS[@]} | tr " " "\n"; \
                      find ${SEARCH_PATHS[@]} -mindepth 1 -maxdepth $MAX_DEPTH -type d 2>/dev/null))

  # Process each directory
  while IFS= read -r dir; do
    [[ -z "$dir" ]] && continue

    local basename_dir=$(basename "$dir")
    local project_type=$(detect_project_type "$dir")
    local git_status=$(get_git_status "$dir")
    local display_line="$dir"

    # Add frecency score if stats enabled
    if [[ "$ENABLE_STATS" == "true" ]]; then
      local stats_entry=$(echo "$stats" | jq -r --arg key "$basename_dir" '.[$key] // empty')

      if [[ -n "$stats_entry" ]]; then
        local count=$(echo "$stats_entry" | jq -r '.count')
        local last_used=$(echo "$stats_entry" | jq -r '.lastUsed')
        local frecency=$(calculate_frecency_score "$count" "$last_used")
        local time_str=$(format_last_used "$last_used")

        # Format with score for sorting
        display_line=$(printf "%06.2f|%s|%s|%s|%s|%s" "$frecency" "$dir" "$count" "$time_str" "$project_type" "$git_status")
      else
        # No stats, default score of 0
        display_line=$(printf "000.00|%s|0|never|%s|%s" "$dir" "$project_type" "$git_status")
      fi
    else
      # No stats, just add project type and git status
      display_line=$(printf "%s|%s|%s" "$dir" "$project_type" "$git_status")
    fi

    directories+=("$display_line")
  done <<< "$found_dirs"

  # Sort by frecency (first field) if stats enabled
  if [[ "$ENABLE_STATS" == "true" ]]; then
    printf "%s\n" "${directories[@]}" | sort -t'|' -k1 -rn
  else
    printf "%s\n" "${directories[@]}"
  fi
}

format_directory_entry() {
  local line="$1"

  if [[ "$line" =~ \| ]]; then
    if [[ "$ENABLE_STATS" == "true" ]]; then
      local frecency=$(echo "$line" | cut -d'|' -f1)
      local dir=$(echo "$line" | cut -d'|' -f2)
      local count=$(echo "$line" | cut -d'|' -f3)
      local time_str=$(echo "$line" | cut -d'|' -f4)
      local project_type=$(echo "$line" | cut -d'|' -f5)
      local git_status=$(echo "$line" | cut -d'|' -f6)

      # Get icons
      local type_icon=$(get_project_type_icon "$project_type")
      local git_icon=$(get_git_status_icon "$git_status")

      # Add star emoji for top entries (score > 20)
      local star=""
      if (( $(echo "$frecency > 20" | bc -l) )); then
        star="‚≠ê "
      fi

      # Format: [star] [score] [git] [type] path (time, count uses)
      printf "%s%-6.0f  %s %s %s" "$star" "$frecency" "$git_icon" "$type_icon" "$dir"
      if [[ "$count" != "0" ]]; then
        printf "  \033[90m(%s, %dx)\033[0m" "$time_str" "$count"
      fi
      echo
    else
      # No stats mode: just dir|type|git
      local dir=$(echo "$line" | cut -d'|' -f1)
      local project_type=$(echo "$line" | cut -d'|' -f2)
      local git_status=$(echo "$line" | cut -d'|' -f3)

      local type_icon=$(get_project_type_icon "$project_type")
      local git_icon=$(get_git_status_icon "$git_status")

      printf "%s %s %s\n" "$git_icon" "$type_icon" "$dir"
    fi
  else
    echo "$line"
  fi
}

extract_directory_from_line() {
  local line="$1"

  if [[ "$line" =~ \| ]]; then
    if [[ "$ENABLE_STATS" == "true" ]]; then
      echo "$line" | cut -d'|' -f2
    else
      echo "$line" | cut -d'|' -f1
    fi
  else
    # Fallback: extract path from formatted line
    # Remove star, score, icons, and metadata
    echo "$line" | sed -E 's/^[‚≠ê ]*[0-9]+  [^ ]+ [^ ]+ //' | awk '{print $1}'
  fi
}

# Build directory list
directories=$(build_directory_list_with_metadata)

# Format for display
formatted_list=""
while IFS= read -r line; do
  [[ -z "$line" ]] && continue
  formatted_list+="$(format_directory_entry "$line")"$'\n'
done <<< "$directories"

# Show in fzf
selected=$(echo "$formatted_list" | fzf --ansi)

# Extract actual directory path
session=$(extract_directory_from_line "$selected")

[[ -z "$session" ]] && exit 0

# Create session name from directory path
session_name=$(basename "$session" | tr . _)

# Track session launch
track_session_launch "$session"

# Start tmux server if not running
if ! tmux list-sessions 2>/dev/null; then
    tmux start-server
fi

# Create session if it doesn't exist
if ! tmux has-session -t "$session_name" 2>/dev/null; then
    tmux new-session -s "$session_name" -c "$session" -d
fi

# Attach or switch to session depending on context
if [ -z "$TMUX" ]; then
    tmux attach -t "$session_name"
else
    tmux switch-client -t "$session_name"
fi
