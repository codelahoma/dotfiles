-- DO NOT EDIT THIS FILE DIRECTLY
-- This file is generated from init.org - edit that file instead
-- Regenerate from Emacs org-mode using C-c C-v t

-- NOTE: This file is inspired by and borrows heavily from https://github.com/zzamboni/dot-hammerspoon/blob/master/init.org

hs.logger.defaultLogLevel = "info"

hyper = {"alt","cmd","ctrl","shift"}
magic = {"alt","cmd","ctrl"}
meh = {"alt", "ctrl", "shift"}

application = hs.application
hotkey = hs.hotkey
grid = hs.grid
window = hs.window
screen = hs.screen
spotify = hs.spotify
machine = hs.host.localizedName()

hs.loadSpoon("SpoonInstall")

spoon.SpoonInstall.repos.rkspoons = {
  url = "https://github.com/codelahoma/MenuHammer",
  desc = "codelahoma's MenuHammer repo"
}

spoon.SpoonInstall.use_syncinstall = true

Install=spoon.SpoonInstall

hs.loadSpoon("editWithEmacs")
if spoon.editWithEmacs then
  local bindings = {
    edit_selection = {magic, "e"},
    edit_all = {hyper, "e"}
  }
  spoon.editWithEmacs:bindHotkeys(bindings)
end

Install:andUse("WindowGrid",
                {
                  config = { gridGeometries = { { "8x5", "3840x2160"}, { "6x4" } } },
                  start = true
                }
)

hs.grid.HINTS = {
 {'a', 's', 'd', 'f', '6', '7', '8', '0'},
 {'w', 'e', 'r', 't', 'z', 'x', '=', '9'},
 {'b', 'g', 'q', 'v', 'y', 'u', 'i', 'o'},
 {'1', 'p', '/', 'c', 'n', 'm', '.', '-'},
 {'5', '2', '3', '4', 'j', 'k', 'l', ';'},
}

-- Window snapping functions
local function snapLeft()
  local win = hs.window.focusedWindow()
  if win then win:moveToUnit({0, 0, 0.5, 1}) end
end

local function snapRight()
  local win = hs.window.focusedWindow()
  if win then win:moveToUnit({0.5, 0, 0.5, 1}) end
end

local function maximize()
  local win = hs.window.focusedWindow()
  if win then win:moveToUnit({0, 0, 1, 1}) end
end

local function centerWindow()
  local win = hs.window.focusedWindow()
  if win then win:moveToUnit({0.1, 0.1, 0.8, 0.8}) end
end

-- Window snapping keybindings
hotkey.bind(hyper, "left", snapLeft)
hotkey.bind(hyper, "right", snapRight)
hotkey.bind(hyper, "up", maximize)
hotkey.bind(hyper, "down", centerWindow)

local function handleScreenChange()
  local screens = hs.screen.allScreens()
  local count = #screens

  if count == 1 then
    hs.alert.show("Single display mode")
  elseif count == 2 then
    hs.alert.show("Dual display mode")
  else
    hs.alert.show(count .. " displays connected")
  end
end

screenWatcher = hs.screen.watcher.new(handleScreenChange)
screenWatcher:start()

local lastBatteryAlert = 0

local function batteryCallback()
  local pct = hs.battery.percentage()
  -- Guard: no battery present (desktops or unavailable data)
  if pct == nil then return end

  local charging = hs.battery.isCharging()
  local now = os.time()

  -- Debounce: don't alert more than once per 5 minutes
  if now - lastBatteryAlert < 300 then return end

  if pct <= 20 and not charging then
    hs.alert.show("Low battery: " .. math.floor(pct) .. "%", 5)
    lastBatteryAlert = now
  elseif pct >= 80 and charging then
    hs.alert.show("Battery charged: " .. math.floor(pct) .. "%", 3)
    lastBatteryAlert = now
  end
end

batteryWatcher = hs.battery.watcher.new(batteryCallback)
batteryWatcher:start()

local watchedDevices = {
  ["YubiKey"] = "YubiKey connected - ready for auth",
  ["Dygma"] = "Dygma Defy connected",
}

local function usbCallback(data)
  if data.eventType == "added" and data.productName then
    for pattern, message in pairs(watchedDevices) do
      if data.productName:match(pattern) then
        hs.alert.show(message)
        break
      end
    end
  end
end

usbWatcher = hs.usb.watcher.new(usbCallback)
usbWatcher:start()

Qutebrowser = "org.qt-project.Qt.QtWebEngineCore"
Bitbucket = "com.webcatalog.juli.bitbucket"
Jira = "com.webcatalog.juli.jira"
Chrome = "com.google.Chrome"
Spotify = "com.spotify.client"
Notion = "notion.id"
Zoom = "us.zoom.xos"
Safari = "com.apple.Safari"
Arc = "company.thebrowser.Browser"
Comet = "ai.perplexity.comet"

-- DefaultBrowser = Safari
-- DefaultBrowser = Chrome
-- DefaultBrowser = Comet
DefaultBrowser = Arc

Install:andUse("URLDispatcher",
              {
                config = {
                  decode_slack_redir_urls = true,
                  url_patterns = {
                    { "https?://open.spotify.com", Spotify},
                    -- { "https?://www.notion.so", Notion},
                    -- { "https?://*.zoom.us", Zoom}
                  },
                  default_handler = DefaultBrowser
                },
                start = true,
                loglevel = 'debug'
              }
)

local function setHeadphones()
  hs.audiodevice.findOutputByName("soundcore Space One"):setDefaultOutputDevice()
end

local function setSpeakers()
  hs.audiodevice.findOutputByName("CalDigit USB-C Pro Audio"):setDefaultOutputDevice()
end

hotkey.bind(magic, 'space', spotify.displayCurrentTrack)
hotkey.bind(magic, 'h', setHeadphones)
hotkey.bind(magic, 's', setSpeakers)

Install:andUse("KSheet", {
                 hotkeys = {
                   toggle = { hyper, "-" }
                 }
})

hs.loadSpoon("MouseCircle")
spoon.MouseCircle:bindHotkeys({
  show = { meh, "m" }
})

_centeredWindowsFormerPositions = {}
  _appLaunchStats = {}
  _statsFilePath = hs.configdir .. "/app_launch_stats.json"

  -- Load app launch statistics from file
  local function loadAppStats()
     local file = io.open(_statsFilePath, "r")
     if file then
        local content = file:read("*a")
        file:close()
        local success, decoded = pcall(hs.json.decode, content)
        if success and decoded then
           _appLaunchStats = decoded
        end
     end
  end

  -- Save app launch statistics to file
  local function saveAppStats()
     local file = io.open(_statsFilePath, "w")
     if file then
        local encoded = hs.json.encode(_appLaunchStats)
        file:write(encoded)
        file:close()
     end
  end

  -- Track app launch
  local function trackAppLaunch(appName)
     if not _appLaunchStats[appName] then
        _appLaunchStats[appName] = {
           count = 0,
           lastLaunched = nil
        }
     end
     _appLaunchStats[appName].count = _appLaunchStats[appName].count + 1
     _appLaunchStats[appName].lastLaunched = os.time()
     saveAppStats()
  end

  -- Display app launch statistics in graphical window
  _statsWindow = nil

  local function showAppStats()
     -- Convert to sorted array
     local statsArray = {}
     local totalLaunches = 0
     for appName, stats in pairs(_appLaunchStats) do
        table.insert(statsArray, {
           name = appName,
           count = stats.count,
           lastLaunched = stats.lastLaunched
        })
        totalLaunches = totalLaunches + stats.count
     end

     -- Sort by count (descending)
     table.sort(statsArray, function(a, b)
        return a.count > b.count
     end)

     -- Build HTML content
     local html = [[
     <!DOCTYPE html>
     <html>
     <head>
        <style>
           body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
              margin: 0;
              padding: 20px;
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: #333;
           }
           .container {
              max-width: 700px;
              margin: 0 auto;
              background: white;
              border-radius: 12px;
              box-shadow: 0 10px 40px rgba(0,0,0,0.3);
              overflow: hidden;
           }
           .header {
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              padding: 25px;
              text-align: center;
           }
           .header h1 {
              margin: 0;
              font-size: 28px;
              font-weight: 600;
           }
           .header .subtitle {
              margin-top: 8px;
              opacity: 0.9;
              font-size: 14px;
           }
           .stats-table {
              padding: 20px;
           }
           table {
              width: 100%;
              border-collapse: collapse;
           }
           th {
              background: #f8f9fa;
              padding: 12px;
              text-align: left;
              font-weight: 600;
              color: #495057;
              border-bottom: 2px solid #dee2e6;
           }
           td {
              padding: 12px;
              border-bottom: 1px solid #e9ecef;
           }
           tr:hover {
              background: #f8f9fa;
           }
           .rank {
              color: #6c757d;
              font-weight: 600;
              width: 50px;
           }
           .app-name {
              font-weight: 500;
              color: #212529;
           }
           .count {
              font-weight: 600;
              color: #667eea;
              text-align: center;
              width: 80px;
           }
           .last-used {
              color: #6c757d;
              font-size: 13px;
              text-align: right;
              width: 150px;
           }
           .empty-state {
              text-align: center;
              padding: 60px 20px;
              color: #6c757d;
           }
           .footer {
              padding: 15px 20px;
              background: #f8f9fa;
              text-align: center;
              color: #6c757d;
              font-size: 13px;
              border-top: 1px solid #dee2e6;
           }
        </style>
     </head>
     <body>
        <div class="container">
           <div class="header">
              <h1>ðŸ“Š App Launch Statistics</h1>
              <div class="subtitle">Total Launches: ]] .. totalLaunches .. [[</div>
           </div>
           <div class="stats-table">
     ]]

     if #statsArray == 0 then
        html = html .. [[
              <div class="empty-state">
                 <h3>No statistics recorded yet</h3>
                 <p>Start using your app launcher shortcuts to see statistics here.</p>
              </div>
        ]]
     else
        html = html .. [[
              <table>
                 <thead>
                    <tr>
                       <th class="rank">#</th>
                       <th class="app-name">Application</th>
                       <th class="count">Launches</th>
                       <th class="last-used">Last Used</th>
                    </tr>
                 </thead>
                 <tbody>
        ]]

        for i, stat in ipairs(statsArray) do
           local lastUsed = "Never"
           if stat.lastLaunched then
              local timeDiff = os.time() - stat.lastLaunched
              if timeDiff < 60 then
                 lastUsed = "Just now"
              elseif timeDiff < 3600 then
                 lastUsed = string.format("%.0f min ago", timeDiff / 60)
              elseif timeDiff < 86400 then
                 lastUsed = string.format("%.0f hours ago", timeDiff / 3600)
              else
                 lastUsed = string.format("%.0f days ago", timeDiff / 86400)
              end
           end

           html = html .. string.format([[
                    <tr>
                       <td class="rank">%d</td>
                       <td class="app-name">%s</td>
                       <td class="count">%d</td>
                       <td class="last-used">%s</td>
                    </tr>
           ]], i, stat.name, stat.count, lastUsed)
        end

        html = html .. [[
                 </tbody>
              </table>
        ]]
     end

     html = html .. [[
           </div>
           <div class="footer">
              Press ESC or click outside to close
           </div>
        </div>
     </body>
     </html>
     ]]

     -- Close existing window if open
     if _statsWindow then
        _statsWindow:delete()
        _statsWindow = nil
     end

     -- Create webview window
     local mainScreen = hs.screen.mainScreen()
     local mainFrame = mainScreen:frame()
     local windowFrame = {
        x = mainFrame.x + (mainFrame.w - 750) / 2,
        y = mainFrame.y + (mainFrame.h - 600) / 2,
        w = 750,
        h = 600
     }

     _statsWindow = hs.webview.new(windowFrame)
        :windowStyle({"titled", "closable", "utility", "HUD"})
        :html(html)
        :allowTextEntry(false)
        :windowTitle("App Launch Statistics")
        :level(hs.drawing.windowLevels.floating)
        :show()

     -- Add ESC key handler to close window
     local escWatcher = hs.eventtap.new({hs.eventtap.event.types.keyDown}, function(event)
        local keyCode = event:getKeyCode()
        if keyCode == 53 then -- ESC key
           if _statsWindow then
              _statsWindow:delete()
              _statsWindow = nil
              if escWatcher then
                 escWatcher:stop()
              end
              return true
           end
        end
        return false
     end)
     escWatcher:start()

     -- Close window when it loses focus (click outside)
     _statsWindow:windowCallback(function(action)
        if action == "focusChange" then
           if _statsWindow then
              _statsWindow:delete()
              _statsWindow = nil
              if escWatcher then
                 escWatcher:stop()
              end
           end
        end
     end)

     _statsWindow:bringToFront()
  end

  local function centerOnMainDisplay()
     local win = window.focusedWindow()
     local formerPosition = _centeredWindowsFormerPositions[win:id()]
     local bigScreen = screen.find('LG HDR 4K')

     hs.console.printStyledtext(hs.inspect(formerPosition))

     if formerPosition then
        win:move(formerPosition)
        _centeredWindowsFormerPositions[win:id()] = nil
     else 
        _centeredWindowsFormerPositions[win:id()] = win:frame()
        win:centerOnScreen()
        if bigScreen then
           win:centerOnScreen(bigScreen)
        else
           win:centerOnScreen()
        end
     end
  end

  local function appLauncher(app)
    return function()
      -- Track the app launch
      trackAppLaunch(app)

      launched = application.launchOrFocus(app)
      if not launched then
        launched = application.launchOrFocusByBundleID(app)
      end

      wonkyAppsThatFocusButReturnFalse = {'Teams', 'iTerm', '/Applications/Emacs.app'}
      for _, v in ipairs(wonkyAppsThatFocusButReturnFalse) do
         if v == app then
            return
         end
      end

      if not launched then
            hs.alert(app .. " not found")
      end
    end
  end

  local function pasteLauncher()
     return function()
        hs.eventtap.keyStroke({"ctrl", "alt", "cmd"}, "p")
     end
  end

  -- Emacs daemon-aware launcher: focus existing frame or create new one
  local function emacsLauncher()
    return function()
      trackAppLaunch('Emacs')
      local emacs = hs.application.find('Emacs')
      if emacs and emacs.allWindows and #emacs:allWindows() > 0 then
        -- Emacs has a GUI frame, just focus it
        emacs:activate()
      else
        -- No GUI frame exists, create one via emacsclient
        -- -a '' starts daemon if not running, -c creates new frame, -n returns immediately
        hs.task.new('/opt/homebrew/bin/emacsclient', nil, {'-a', '', '-c', '-n'}):start()
        -- Activate Emacs after frame creation (slight delay for frame to appear)
        hs.timer.doAfter(0.3, function()
          local app = hs.application.find('Emacs')
          if app then app:activate() end
        end)
      end
    end
  end

  -- Quick Org Capture: trigger org-capture with inbox template
  local function quickOrgCapture()
    -- Trigger org-capture with inbox template
    -- -a '' starts daemon if not running
    hs.task.new('/opt/homebrew/bin/emacsclient', nil,
      {'-a', '', '-e', '(org-capture nil "i")'}):start()
    -- Focus Emacs after a brief delay for capture buffer
    hs.timer.doAfter(0.3, function()
      local emacs = hs.application.find('Emacs')
      if emacs then emacs:activate() end
    end)
  end

  -- Brain dump: prompt in minibuffer, append directly to inbox
  local function brainDump()
    -- Elisp: prompt for text, append as TODO to inbox.org
    local elisp = [[(let ((text (read-string "Brain dump: ")))
      (when (> (length text) 0)
        (with-current-buffer (find-file-noselect "~/Dropbox/org/gtd/inbox.org")
          (goto-char (point-max))
          (insert "\n* TODO " text "\n")
          (save-buffer))
        (message "Captured: %s" text)))]]
    hs.task.new('/opt/homebrew/bin/emacsclient', nil,
      {'-a', '', '-e', elisp}):start()
    -- Focus Emacs for minibuffer prompt
    hs.timer.doAfter(0.2, function()
      local emacs = hs.application.find('Emacs')
      if emacs then emacs:activate() end
    end)
  end

  -- Quick Journal: open org-roam daily note for today with timestamp heading
  local function quickJournal()
    local elisp = [[(progn
      (require 'org-roam-dailies)
      (org-roam-dailies-goto-today)
      (goto-char (point-max))
      (unless (bolp) (insert "\n"))
      (insert "** " (format-time-string "%H:%M") "\n")
      (evil-insert-state))]]
    hs.task.new('/opt/homebrew/bin/emacsclient', nil,
      {'-a', '', '-c', '-e', elisp}):start()
    hs.timer.doAfter(0.3, function()
      local emacs = hs.application.find('Emacs')
      if emacs then emacs:activate() end
    end)
  end

  -- Clock Toggle: clock in/out of last task
  local function clockToggle()
    local elisp = [[(if (org-clocking-p)
      (progn (org-clock-out) (message "Clocked out"))
      (progn (org-clock-in-last) (message "Clocked in: %s" org-clock-heading)))]]
    hs.task.new('/opt/homebrew/bin/emacsclient', nil,
      {'-a', '', '-e', elisp}):start()
  end

  -- Note to Clocked Task: add timestamped note to current clock
  local function noteToClocked()
    local elisp = [[(if (org-clocking-p)
      (let ((note (read-string "Note: ")))
        (when (> (length note) 0)
          (save-excursion
            (org-clock-goto)
            (org-end-of-subtree)
            (insert "\n- " (format-time-string "[%Y-%m-%d %H:%M] ") note)
            (save-buffer))
          (message "Note added")))
      (message "No task clocked in"))]]
    hs.task.new('/opt/homebrew/bin/emacsclient', nil,
      {'-a', '', '-e', elisp}):start()
    hs.timer.doAfter(0.2, function()
      local emacs = hs.application.find('Emacs')
      if emacs then emacs:activate() end
    end)
  end

  -- Agenda Today: show today's agenda in new frame
  local function agendaToday()
    local elisp = [[(progn
      (org-agenda nil "a")
      (org-agenda-day-view))]]
    hs.task.new('/opt/homebrew/bin/emacsclient', nil,
      {'-a', '', '-c', '-e', elisp}):start()
    hs.timer.doAfter(0.3, function()
      local emacs = hs.application.find('Emacs')
      if emacs then emacs:activate() end
    end)
  end

  -- Link Capture: capture browser URL + title to inbox
  local function linkCapture()
    -- Get URL from frontmost browser
    local script = [[
      tell application "System Events"
        set frontApp to name of first application process whose frontmost is true
      end tell
      if frontApp is "Arc" then
        tell application "Arc" to return URL of active tab of front window & "\n" & title of active tab of front window
      else if frontApp is "Safari" then
        tell application "Safari" to return URL of front document & "\n" & name of front document
      else if frontApp is "Google Chrome" then
        tell application "Google Chrome" to return URL of active tab of front window & "\n" & title of active tab of front window
      else
        return ""
      end if
    ]]

    local ok, result = hs.osascript.applescript(script)
    if ok and result and result ~= "" then
      local url, title = result:match("([^\n]+)\n?(.*)")
      title = title or url
      -- Escape quotes for elisp
      url = url:gsub('"', '\\"')
      title = title:gsub('"', '\\"')

      local elisp = string.format([=[(with-current-buffer (find-file-noselect "~/Dropbox/org/gtd/inbox.org")
        (goto-char (point-max))
        (insert "\n* TODO [[%s][%s]]\n")
        (save-buffer)
        (message "Captured: %s"))]=], url, title, title)
      hs.task.new('/opt/homebrew/bin/emacsclient', nil,
        {'-a', '', '-e', elisp}):start()
    else
      hs.alert.show("No browser URL found")
    end
  end

  function open750()
    local url = "https://new.750words.com"
    local script = string.format([[
# shows all url+titles of Chrome along with front window+tab url+title
set titleString to ""
set windowFound to false
set tabFound to false

tell application "Google Chrome"
  set window_list to every window # get the windows

  repeat with the_window in window_list # for every window
    set tab_list to every tab in the_window # get the tabs
    set tab_index to 0
    repeat with the_tab in tab_list # for every tab
      set tab_index to tab_index + 1
      set the_title to the title of the_tab
      if the_title contains "V2 - 750 Words" then
        set windowFound to true
        set tabFound to true
        set active tab index of the_window to tab_index
      end if
    end repeat
    if windowFound then exit repeat
  end repeat
  if not tabFound then
    set newTab to make new tab at end of tabs of window 1
    set URL of newTab to "https://new.750words.com"
	
  end if

  activate

end tell


      ]], url, url)

    hs.osascript.applescript(script)
  end

hotkey.bind(hyper, "a", appLauncher('Stickies'))
hotkey.bind(hyper, "b", appLauncher('ChatGPT'))
hotkey.bind(magic, "b", appLauncher('Bazecor'))
hotkey.bind(hyper, "c", hs.toggleConsole)
hotkey.bind(magic, "c", appLauncher('Claude'))
hotkey.bind(hyper, "d", appLauncher('Dash'))
hotkey.bind(magic, "d", appLauncher('Discord'))
hotkey.bind(hyper, "f", appLauncher('DBeaver'))
hotkey.bind(hyper, "i", appLauncher('iTerm'))
hotkey.bind(hyper, "j", emacsLauncher())
hotkey.bind(hyper, "k", appLauncher('Arc'))
hotkey.bind(magic, "k", appLauncher('Marked'))
hotkey.bind(meh, "k", appLauncher('Google Chrome'))
hotkey.bind(hyper, "l", appLauncher('Fantastical'))
hotkey.bind(hyper, "m", appLauncher('Spark Mail'))
hotkey.bind(hyper, "o", appLauncher('Slack'))
hotkey.bind(hyper, "p", appLauncher('Perplexity'))
hotkey.bind(hyper, "q", appLauncher('1Password'))
hotkey.bind(hyper, "r", hs.reload)
hotkey.bind(hyper, "s", hs.grid.show)
hotkey.bind(magic, "s", appLauncher("Safari"))
hotkey.bind(hyper, "t", appLauncher("DEVONthink 3"))
hotkey.bind(hyper, "u", open750)
hotkey.bind(hyper, "v", pasteLauncher())
hotkey.bind(magic, "z", appLauncher("Zotero"))
hotkey.bind(hyper, ";", appLauncher('Spotify'))
hotkey.bind(hyper, "0", centerOnMainDisplay)
hotkey.bind(magic, "/", showAppStats)
hotkey.bind(magic, "n", quickOrgCapture)
hotkey.bind(magic, "i", brainDump)
hotkey.bind(magic, "j", quickJournal)
hotkey.bind(magic, "t", clockToggle)
hotkey.bind(magic, "o", noteToClocked)
hotkey.bind(magic, "a", agendaToday)
hotkey.bind(magic, "l", linkCapture)

caffeine = hs.menubar.new()
hs.caffeinate.set("system", true, false)

local function setCaffeineDisplay(state)
  if state then
    caffeine:setIcon("caffeine-on.pdf")
  else
    caffeine:setIcon("caffeine-off.pdf")
  end
end

local function caffeineClicked()
  setCaffeineDisplay(hs.caffeinate.toggle("system"))
end

if caffeine then
  caffeine:setClickCallback(caffeineClicked)
  setCaffeineDisplay(hs.caffeinate.get("system"))
end

local localfile = hs.configdir .. "/init-local.lua"

if hs.fs.attributes(localfile) then
  dofile(localfile)
end

hs.ipc.cliInstall("/opt/homebrew")

loadAppStats()

hs.alert.show("Config Loaded")
