#+property: header-args:lua :tangle (concat (file-name-sans-extension (buffer-file-name)) ".lua")
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+begin_src lua :exports none
  -- DO NOT EDIT THIS FILE DIRECTLY
  -- This is a file generated from a literate programing source file located at :TBD:
  -- You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t

  -- NOTE: This file is inspired by and borrows heavily from https://github.com/zzamboni/dot-hammerspoon/blob/master/init.org
#+end_src

#+title: My Hammerspoon config file
#+author: Rod Knowlton
#+email: rod@codelahoma.com

* Table of Contents :TOC_3:noexport:
- [[#auto-reset-hammerspoon-on-tangle][Auto-reset Hammerspoon on Tangle]]
- [[#general-variables-and-configuration][General Variables and Configuration]]
- [[#joshs-window-functions][Josh's Window functions]]
- [[#spoon-management][Spoon Management]]
- [[#edit-in-emacs][Edit in Emacs]]
- [[#menu-hammer---spacemacs-style-modal-menu-manager-wip][Menu Hammer - Spacemacs style modal menu manager (wip)]]
- [[#window-and-screen-manipulation][Window and Screen Manipulation]]
- [[#url-dispatching-to-site-specific-browsers][URL dispatching to site-specific browsers]]
- [[#global-key-bindings][Global Key Bindings]]
- [[#show-application-keybindings][Show application keybindings]]
- [[#fast-navigation-to-core-apps][Fast navigation to core apps]]
  - [[#helper-functions][Helper Functions]]
  - [[#key-bindings][Key Bindings]]
- [[#hotkey-model-madness][Hotkey Model Madness]]
- [[#caffeinate][Caffeinate]]
- [[#load-local-config][Load Local Config]]
- [[#wrap-up][Wrap Up]]

* Auto-reset Hammerspoon on Tangle
#+NAME: my-tangle-hook
#+BEGIN_SRC emacs-lisp :results silent :post "my-after-tangle-function"
  (defun my-after-tangle-function ()
    (rk/reset-hammerspoon))
  #+end_src

* General Variables and Configuration

Global log level. Per-spoon log level can be configured in each =Install:andUse= block below.

#+begin_src lua
  hs.logger.defaultLogLevel = "info"
#+end_src

Define my primary modifier combinations,  =hyper= and =magic=

#+begin_src lua
  hyper = {"alt","cmd","ctrl","shift"}
  magic = {"alt","cmd","ctrl"}
  meh = {"alt", "ctrl", "shift"}
#+end_src

Abbreviations for frequently used modules

#+begin_src lua
  application = hs.application
  hotkey = hs.hotkey
  grid = hs.grid
  window = hs.window
  screen = hs.screen
  spotify = hs.spotify
  machine = hs.host.localizedName()
#+end_src

Which systems are work and which are home

#+begin_src lua
  work_machines = {["codelahoma"] = true, ["codelahoma-kw"] = true, ["codelahoma-kw-m1"] = true, ["codelahoma-atlasup"] = true }
  home_machines = {["m1-mini"] = true}
#+end_src

#+RESULTS:

* Josh's Window functions
#+begin_src lua 
  -- -- https://github.com/fikovnik/ShiftIt/wiki/The-Hammerspoon-Alternative
  -- -- https://github.com/derekwyatt/dotfiles/blob/master/hammerspoon-init.lua
  -- hs.window.animationDuration = 0
  -- units = {
  --   right30       = { x = 0.70, y = 0.00, w = 0.30, h = 1.00 },
  --   right50       = { x = 0.50, y = 0.00, w = 0.50, h = 1.00 },
  --   right70       = { x = 0.30, y = 0.00, w = 0.70, h = 1.00 },
  --   left70        = { x = 0.00, y = 0.00, w = 0.70, h = 1.00 },
  --   left50        = { x = 0.00, y = 0.00, w = 0.50, h = 1.00 },
  --   left30        = { x = 0.00, y = 0.00, w = 0.30, h = 1.00 },
  --   top50         = { x = 0.00, y = 0.00, w = 1.00, h = 0.50 },
  --   bot50         = { x = 0.00, y = 0.50, w = 1.00, h = 0.50 },
  --   upright30     = { x = 0.70, y = 0.00, w = 0.30, h = 0.50 },
  --   botright30    = { x = 0.70, y = 0.50, w = 0.30, h = 0.50 },
  --   upleft70      = { x = 0.00, y = 0.00, w = 0.70, h = 0.50 },
  --   botleft70     = { x = 0.00, y = 0.50, w = 0.70, h = 0.50 },
  --   maximum       = { x = 0.00, y = 0.00, w = 1.00, h = 1.00 }
  -- }

  -- -- hs.hotkey.bind(meh, 'l', function() hs.window.focusedWindow():move(units.right30,    nil, true) end)
  -- -- hs.hotkey.bind(meh, 'h', function() hs.window.focusedWindow():move(units.left70,     nil, true) end)
  -- hs.hotkey.bind(meh, 'l', function() hs.window.focusedWindow():move(units.right50,    nil, true) end)
  -- hs.hotkey.bind(meh, 'h', function() hs.window.focusedWindow():move(units.left50,     nil, true) end)
  -- hs.hotkey.bind(meh, 'k', function() hs.window.focusedWindow():move(units.top50,      nil, true) end)
  -- hs.hotkey.bind(meh, 'j', function() hs.window.focusedWindow():move(units.bot50,      nil, true) end)
  -- hs.hotkey.bind(meh, ']', function() hs.window.focusedWindow():move(units.upright30,  nil, true) end)
  -- hs.hotkey.bind(meh, '[', function() hs.window.focusedWindow():move(units.upleft70,   nil, true) end)
  -- hs.hotkey.bind(meh, ';', function() hs.window.focusedWindow():move(units.botleft70,  nil, true) end)
  -- hs.hotkey.bind(meh, "'", function() hs.window.focusedWindow():move(units.botright30, nil, true) end)
  -- hs.hotkey.bind(meh, 'm', function() hs.window.focusedWindow():move(units.maximum,    nil, true) end)

  -- -- https://stackoverflow.com/a/58662204
  -- hs.hotkey.bind(meh, 'n', function()
  --     -- get the focused window
  --     local win = hs.window.focusedWindow()
  --     -- get the screen where the focused window is displayed, a.k.a. current screen
  --     local screen = win:screen()
  --     -- compute the unitRect of the focused window relative to the current screen
  --     -- and move the window to the next screen setting the same unitRect
  --     win:move(win:frame():toUnitRect(screen:frame()), screen:next(), true, 0)
  -- end)
#+end_src

* Spoon Management 

Set up SpoonInstall - this is the only spoon that needs to be manually installed (it is already there if you check out this repository), all the others are installed and configured automatically.

#+begin_src lua
  hs.loadSpoon("SpoonInstall")
#+end_src

Add my private MenuHammer repository

#+begin_src lua
  spoon.SpoonInstall.repos.rkspoons = {
    url = "https://github.com/codelahoma/MenuHammer",
    desc = "codelahoma's MenuHammer repo"
  }
#+end_src

I prefer sync notifications, makes them easier to read.

#+begin_src lua
  spoon.SpoonInstall.use_syncinstall = true
#+end_src

This is just a shortcut to make the declarations below look more readable, i.e. =Install:andUse= instead of =spoon.SpoonInstall:andUse=.

#+begin_src lua
  Install=spoon.SpoonInstall
#+end_src

* Edit in Emacs
A spoon to allow editing with Emacs from any textbox in macOS.

#+begin_src lua
  hs.loadSpoon("editWithEmacs")
  if spoon.editWithEmacs then
    local bindings = {
      edit_selection = {magic, "e"},
      edit_all = {hyper, "e"}
    }
    spoon.editWithEmacs:bindHotkeys(bindings)
  end
#+end_src

* Menu Hammer - Spacemacs style modal menu manager (wip)

Load MenuHammer directly because it's not in a repository yet.

#+begin_src lua
  menuHammer = hs.loadSpoon("MenuHammer")
  menuHammer:enter()
#+end_src

#+begin_src lua :tangle no
  Install:andUse("MenuHammer", { repo = 'rkspoons'})
  spoon.MenuHammer:enter()
#+end_src

* Window and Screen Manipulation

The [[http://www.hammerspoon.org/Spoons/WindowGrid.html][WindowGrid]] spoon sets up a key binding (=Hyper-8= here) to overlay a grid that allows resizing windows by specifying their opposite corners.

#+begin_src lua
  Install:andUse("WindowGrid",
                  {
                    config = { gridGeometries = { { "8x5", "3840x2160"}, { "6x4" } } },
                    start = true
                  }
  )

  hs.grid.HINTS = {
   {'a', 's', 'd', 'f', '6', '7', '8', '0'}, 
   {'w', 'e', 'r', 't', 'z', 'x', '=', '9'}, 
   {'b', 'g', 'q', 'v', 'y', 'u', 'i', 'o'}, 
   {'1', 'p', '/', 'c', 'n', 'm', '.', '-'}, 
   {'5', '2', '3', '4', 'j', 'k', 'l', ';'}, 
  }

#+end_src


* URL dispatching to site-specific browsers

#+begin_src lua 
  Qutebrowser = "org.qt-project.Qt.QtWebEngineCore"
  Bitbucket = "com.webcatalog.juli.bitbucket"
  Jira = "com.webcatalog.juli.jira"
  Chrome = "com.google.Chrome"
  Spotify = "com.spotify.client"
  Notion = "notion.id"
  Zoom = "us.zoom.xos"
  Safari = "com.apple.Safari"

  -- DefaultBrowser = Safari
  DefaultBrowser = Chrome
  if  work_machines[machine] ~= nil  then
    Install:andUse("URLDispatcher",
                  {
                    config = {
                      decode_slack_redir_urls = true,
                      url_patterns = {
                        { "https?://open.spotify.com", Spotify},
                        -- { "https?://www.notion.so", Notion},
                        -- { "https?://*.zoom.us", Zoom}
                      },
                      default_handler = DefaultBrowser
                    },
                    start = true,
                    loglevel = 'debug'
                  }
    )
  end

  if home_machines[machine] ~= nil then
    Install:andUse("URLDispatcher",
                  {
                    config = {
                      url_patterns = {
                      },
                      url_redir_decoders = {
                      },
                      default_handler = DefaultBrowser
                    },
                    start = true,
                    --                   loglevel = 'debug'
                  }
    )

  end
#+end_src

* Global Key Bindings

What's playing?

#+begin_src lua
  local function setHeadphones()
    hs.audiodevice.findOutputByName("soundcore Space One"):setDefaultOutputDevice()
  end

  local function setSpeakers()
    hs.audiodevice.findOutputByName("CalDigit USB-C Pro Audio"):setDefaultOutputDevice()
  end

  hotkey.bind(magic, 'space', spotify.displayCurrentTrack)
  hotkey.bind(magic, 'h', setHeadphones)
  hotkey.bind(magic, 's', setSpeakers)
#+end_src

* Show application keybindings

The KSheet spoon provides for showing the keybindings for the currently active application.

#+begin_src lua
  Install:andUse("KSheet", {
                   hotkeys = {
                     toggle = { hyper, "-" }
                   }
  })
#+end_src
* Fast navigation to core apps 

** Helper Functions
#+begin_src lua
    _centeredWindowsFormerPositions = {}

    local function centerOnMainDisplay()
       local win = window.focusedWindow()
       local formerPosition = _centeredWindowsFormerPositions[win:id()]
       local bigScreen = screen.find('LG HDR 4K')

       hs.console.printStyledtext(hs.inspect(formerPosition))

       if formerPosition then
          win:move(formerPosition)
          _centeredWindowsFormerPositions[win:id()] = nil
       else 
          _centeredWindowsFormerPositions[win:id()] = win:frame()
          win:centerOnScreen()
          if bigScreen then
             win:centerOnScreen(bigScreen)
          else
             win:centerOnScreen()
          end
       end
    end

    local function appLauncher(app)
      return function()
        launched = application.launchOrFocus(app) 
        if not launched then
          launched = application.launchOrFocusByBundleID(app)
        end

        wonkyAppsThatFocusButReturnFalse = {'Teams', 'iTerm', '/Applications/Emacs.app'}
        for _, v in ipairs(wonkyAppsThatFocusButReturnFalse) do
           if v == app then
              return
           end
        end

        if not launched then
              hs.alert(app .. " not found")
        end
      end
    end

    local function pasteLauncher()
       return function()
          hs.eventtap.keyStroke({"ctrl", "alt", "cmd"}, "p")
       end
    end

    function open750()
      local url = "https://new.750words.com"
      local script = string.format([[
  # shows all url+titles of Chrome along with front window+tab url+title
  set titleString to ""
  set windowFound to false
  set tabFound to false

  tell application "Google Chrome"
    set window_list to every window # get the windows

    repeat with the_window in window_list # for every window
      set tab_list to every tab in the_window # get the tabs
      set tab_index to 0
      repeat with the_tab in tab_list # for every tab
        set tab_index to tab_index + 1
        set the_title to the title of the_tab
        if the_title contains "V2 - 750 Words" then
          set windowFound to true
          set tabFound to true
          set active tab index of the_window to tab_index
        end if
      end repeat
      if windowFound then exit repeat
    end repeat
    if not tabFound then
      set newTab to make new tab at end of tabs of window 1
      set URL of newTab to "https://new.750words.com"
  	
    end if

    activate

  end tell


        ]], url, url)

      hs.osascript.applescript(script)
    end


  -- **1. Define the profile identifiers (internal folder names from chrome://version):**
  local profileWork     = "Profile 1"      -- e.g. rod@atlasup.com profile's folder name
  local profilePersonal = "Default"        -- e.g. rod.knowlton@gmail.com profile's folder name

  -- **2. Define unique window name markers for each profile:**
  local winNameWork     = "rod@atlasup.com - Google Chrome"      -- Window name for Work profile (set via Chrome or flag)
  local winNamePersonal = "rod.knowlton@gmail.com - Google Chrome"  -- Window name for Personal profile

  -- **3. Function to focus an existing profile window or open a new one:**
  function focusOrOpenChromeProfile(profileDir, windowName, url)
      -- Log the function call and parameters
      hs.console.printStyledtext(string.format(
          "üîç Invoking focusOrOpenChromeProfile:\n  profileDir = %s\n  windowName = %s\n  url = %s\n",
          profileDir, windowName, url
      ))

      local chromeWindows = hs.window.filter.new(false):setAppFilter("Google Chrome"):getWindows()
      for _, win in ipairs(chromeWindows) do
          local title = win:title():lower()
          if title:find(windowName:lower(), 1, true) then
              hs.console.printStyledtext("‚úÖ Found matching Chrome window. Focusing it now.\n")
              win:focus()
              return
          end
      end

      -- Log fallback
      hs.console.printStyledtext("üöÄ No matching window found. Launching new Chrome window...\n")

      -- Launch new Chrome window with specified profile and URL
      hs.task.new("/Applications/Google Chrome.app/Contents/MacOS/Google Chrome", nil, function()
          hs.console.printStyledtext("üì¶ Chrome task finished (or failed to start).\n")
          return false
      end, {
          "--profile-directory=" .. profileDir,
          "--new-window",
          "--window-name=" .. windowName,
          url
      }):start()
  end
#+end_src

#+RESULTS:

** Key Bindings

#+begin_src lua
  hotkey.bind(hyper, "a", appLauncher('Stickies'))
  hotkey.bind(hyper, "b", appLauncher('ChatGPT'))
  hotkey.bind(magic, "b", appLauncher('Bazecor'))
  hotkey.bind(hyper, "c", hs.toggleConsole)
  hotkey.bind(magic, "c", appLauncher('Claude'))
  hotkey.bind(hyper, "d", appLauncher('Dash'))
  hotkey.bind(magic, "d", appLauncher('Discord'))
  hotkey.bind(hyper, "f", appLauncher('DBeaver'))
  hotkey.bind(hyper, "i", appLauncher('iTerm'))
  hotkey.bind(hyper, "j", appLauncher('Emacs'))
  hotkey.bind(hyper, "k", appLauncher('Google Chrome'))
  hotkey.bind(magic, "k", appLauncher('Marked'))
  hotkey.bind(hyper, "l", appLauncher('Fantastical'))
  hotkey.bind(hyper, "m", appLauncher('Spark Mail'))
  hotkey.bind(hyper, "o", appLauncher('Slack'))
  hotkey.bind(hyper, "p", appLauncher('Perplexity AI'))
  hotkey.bind(hyper, "q", appLauncher('1Password'))
  hotkey.bind(hyper, "r", hs.reload)
  hotkey.bind(hyper, "s", hs.grid.show)
  hotkey.bind(magic, "s", appLauncher("Safari"))
  hotkey.bind(hyper, "t", appLauncher("DEVONthink 3"))
  hotkey.bind(hyper, "u", open750)
  hotkey.bind(hyper, "v", pasteLauncher())
  hotkey.bind(magic, "z", appLauncher("Zotero"))
  hotkey.bind(hyper, ";", appLauncher('Spotify'))
  hotkey.bind(hyper, "0", centerOnMainDisplay)
#+end_src

#+RESULTS:

If it's my work laptop, the work set, otherwise my personal set.

* Hotkey Model Madness

#+begin_src lua
  -- menuModal = hs.hotkey.modal.new(hyper, "n")
  -- menuModal.alertUID = ""
  -- menuModal.alertText = [[
  -- Modal Menu
  -- ----------
  -- a - Activity Monitor
  -- b - Brave Browser Dev
  -- c - Google Calendar
  -- d - Dash
  -- m - Mail (removed MailMate)
  -- n - Notion
  -- p - Postman
  -- s - Stickies
  -- v - Paste

  -- ESC - exit
  -- ]]


  -- function menuModal:entered()
  --    self.alertUID = hs.alert(self.alertText, "forever")
  -- end

  -- function menuModal:exited()
  --  i hs.alert.closeSpecific(self.alertUID)
  -- end

  -- -- in this example, Ctrl+Shift+h triggers this keybinding mode, which will allow us to use the ones defined below. A nice touch for usability: This also offers to show a message.

  -- -- I recommend having this one at all times: Bind the escape key to exit keybinding mode:
  -- menuModal:bind("", "escape", " not this time...", nil, function() menuModal:exit() end, nil)

  -- -- An example binding I find useful: Type today's date in ISO format.
  -- -- menuModal:bind("", "d", "today", nil, function() hs.eventtap.keyStrokes(os.date("%F")) menuModal:exit() end, nil)
  -- menuModal:bind("", "a", "activity", nil, function() application.launchOrFocus("Activity Monitor") menuModal:exit() end, nil)
  -- menuModal:bind("", "b", "Brave Browser Dev", nil, function() application.launchOrFocus("Brave Browser Dev") menuModal:exit() end, nil)
  -- menuModal:bind("", "c", "Google Calendar", nil, function() application.launchOrFocusByBundleID("com.webcatalog.juli.google-calendar") menuModal:exit() end, nil)
  -- menuModal:bind("", "d", "dash", nil, function() application.launchOrFocus("Dash") menuModal:exit() end, nil)
  -- menuModal:bind("", "m", "Mail", nil, function() application.launchOrFocus("Mail") menuModal:exit() end, nil)
  -- menuModal:bind("", "n", "Notion", nil, function() application.launchOrFocus("Notion") menuModal:exit() end, nil)
  -- menuModal:bind("", "p", "postman", nil, function() application.launchOrFocus("Postman") menuModal:exit() end, nil)
  -- menuModal:bind("", "s", "stickies", nil, function() application.launchOrFocus("Stickies") menuModal:exit() end, nil)
  -- menuModal:bind("", "v", "paste", nil, function() hs.eventtap.keyStroke({"cmd", "shift"}, "v") menuModal:exit() end, nil)
#+end_src

#+RESULTS:

* Caffeinate

#+begin_src lua
  caffeine = hs.menubar.new()
  hs.caffeinate.set("system", true, false)

  local function setCaffeineDisplay(state)
    if state then
      caffeine:setIcon("caffeine-on.pdf")
    else
      caffeine:setIcon("caffeine-off.pdf")
    end
  end

  local function caffeineClicked()
    setCaffeineDisplay(hs.caffeinate.toggle("system"))
  end

  if caffeine then
    caffeine:setClickCallback(caffeineClicked)
    setCaffeineDisplay(hs.caffeinate.get("system"))
  end
#+end_src

* Load Local Config

#+begin_src lua
  local localfile = hs.configdir .. "/init-local.lua"

  if hs.fs.attributes(localfile) then
    dofile(localfile)
  end
#+end_src

* Wrap Up

Make sure Hammerspoon cli is installed

#+begin_src lua
  hs.ipc.cliInstall("/opt/homebrew")
#+end_src

Heads up that we're done

#+begin_src lua
  hs.alert.show("Config Loaded")
#+end_src
