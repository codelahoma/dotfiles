#!/usr/bin/env python3
"""
FlowLoom Claude Bridge - Processes UI commands and generates Claude responses

This script runs alongside the FlowLoom web server to handle commands from the UI
and route them through Claude for processing, then return formatted responses.
"""

import asyncio
import json
import logging
import signal
import sys
import tempfile
import time
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

import websockets

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class FlowLoomClaudeBridge:
    """Bridge between FlowLoom UI and Claude processing."""
    
    def __init__(self, flowloom_ws_url: str = "ws://localhost:8891/ws"):
        self.flowloom_ws_url = flowloom_ws_url
        self.websocket = None
        self.running = False
        self.command_counter = 0
        
        # Set up signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully."""
        logger.info(f"Received signal {signum}, shutting down...")
        self.running = False
    
    async def connect(self):
        """Connect to FlowLoom WebSocket server."""
        try:
            logger.info(f"Connecting to FlowLoom server at {self.flowloom_ws_url}")
            self.websocket = await websockets.connect(self.flowloom_ws_url)
            logger.info("‚úÖ Connected to FlowLoom server")
            return True
        except Exception as e:
            logger.error(f"‚ùå Failed to connect to FlowLoom server: {e}")
            return False
    
    async def disconnect(self):
        """Disconnect from WebSocket server."""
        if self.websocket:
            await self.websocket.close()
            logger.info("Disconnected from FlowLoom server")
    
    def process_claude_command(self, command: str) -> Dict[str, Any]:
        """
        Process a command through Claude (simulated for now).
        In a real implementation, this would interface with Claude.
        """
        self.command_counter += 1
        command_lower = command.lower().strip()
        
        # Generate timestamp
        timestamp = datetime.now().isoformat()
        
        # Simulate Claude processing different types of commands
        if any(word in command_lower for word in ['help', 'what', 'how', '?']):
            return {
                "type": "claude_response",
                "presentation": f"""
# Claude Response to: "{command}"

This is a **simulated Claude response** to demonstrate the UI-Claude integration.

## Command Analysis
- **Input**: {command}
- **Type**: Help/Question  
- **Processed at**: {timestamp}
- **Command #**: {self.command_counter}

## Simulated Response
Claude would analyze your question and provide:
- Detailed explanations
- Code examples if relevant  
- Step-by-step guidance
- References and links

## Integration Status
‚úÖ **UI ‚Üí Bridge**: Command received  
‚úÖ **Bridge ‚Üí Claude**: Processing simulated  
‚úÖ **Claude ‚Üí Bridge**: Response generated  
‚úÖ **Bridge ‚Üí UI**: Formatted response ready

**Note**: This is a demonstration. Real Claude integration would process your actual request.
                """,
                "conversation": f"Processed your question: '{command}'. This demonstrates the UI-Claude bridge working!",
                "format": "markdown",
                "metadata": {
                    "command_executed": command,
                    "execution_time": 0.2,
                    "session_id": f"claude-bridge-{int(time.time())}",
                    "plan_context": "UI-Claude integration testing"
                }
            }
        
        elif any(word in command_lower for word in ['code', 'function', 'class', 'implement']):
            return {
                "type": "claude_response", 
                "presentation": f"""
// Claude Code Response: {command}
func exampleFunction() {{
    // This would be actual code generated by Claude
    print("Command received: {command}")
    print("Timestamp: {timestamp}")
    
    // Real Claude would generate:
    // - Functional code based on your request
    // - Proper error handling
    // - Documentation and comments
    // - Best practices implementation
}}

// Usage example:
exampleFunction()
                """,
                "conversation": f"Generated code example for: '{command}'. Claude integration is working!",
                "format": "code",
                "language": "swift",
                "metadata": {
                    "command_executed": command,
                    "execution_time": 0.3,
                    "session_id": f"claude-bridge-{int(time.time())}",
                    "plan_context": "UI-Claude integration testing"
                }
            }
        
        elif any(word in command_lower for word in ['status', 'health', 'check']):
            return {
                "type": "claude_response",
                "presentation": """
| Component | Status | Details |
|-----------|--------|---------|
| UI-Claude Bridge | ‚úÖ Active | Processing commands successfully |
| WebSocket Connection | ‚úÖ Connected | Real-time communication established |
| Command Processing | ‚úÖ Working | Simulated Claude responses |
| Response Formatting | ‚úÖ Working | Multiple formats supported |
| Integration Test | ‚úÖ Passed | End-to-end flow functional |
                """,
                "conversation": f"System status check completed. All components operational!",
                "format": "markdown",
                "metadata": {
                    "command_executed": command,
                    "execution_time": 0.1,
                    "session_id": f"claude-bridge-{int(time.time())}",
                    "plan_context": "UI-Claude integration testing"
                }
            }
        
        else:
            return {
                "type": "claude_response",
                "presentation": f"""
# Claude Processing: "{command}"

## Command Received
Your command has been received by the Claude bridge and would normally be processed by Claude.

## What Would Happen
1. **Command Analysis**: Claude would analyze: "{command}"
2. **Context Consideration**: Previous conversation and project context
3. **Response Generation**: Appropriate response based on command type
4. **Format Selection**: Best format for the response (markdown, code, etc.)

## Current Status
This is a **bridge demonstration**. The infrastructure is working:
- ‚úÖ UI sent command via WebSocket
- ‚úÖ Bridge received and parsed command  
- ‚úÖ Response formatted and ready to return
- ‚úÖ UI will display this formatted response

## Next Steps
To enable full Claude integration:
1. Connect bridge to actual Claude session
2. Implement context preservation
3. Add authentication if needed
4. Enable real-time conversation flow

**Your command**: `{command}`  
**Processed at**: {timestamp}
                """,
                "conversation": f"Received command: '{command}'. Bridge is working - ready for full Claude integration!",
                "format": "markdown",
                "metadata": {
                    "command_executed": command,
                    "execution_time": 0.15,
                    "session_id": f"claude-bridge-{int(time.time())}",
                    "plan_context": "UI-Claude integration testing"
                }
            }
    
    async def handle_message(self, message: str):
        """Handle incoming WebSocket message from FlowLoom UI."""
        try:
            # Parse the JSON message
            data = json.loads(message)
            logger.info(f"Received message: {data}")
            
            # Check if this is a command from the UI
            if data.get("type") == "command" and "input" in data:
                command = data["input"]
                logger.info(f"Processing command: {command}")
                
                # Process through Claude (simulated)
                response = self.process_claude_command(command)
                
                # Send response back to UI
                await self.websocket.send(json.dumps(response))
                logger.info(f"Sent response for command: {command}")
            
            else:
                # Echo back other messages (existing behavior)
                echo_response = {
                    "type": "echo",
                    "message": message,
                    "timestamp": datetime.now().isoformat()
                }
                await self.websocket.send(json.dumps(echo_response))
                
        except json.JSONDecodeError:
            logger.error(f"Failed to parse JSON message: {message}")
        except Exception as e:
            logger.error(f"Error handling message: {e}")
    
    async def run(self):
        """Main event loop for the bridge."""
        self.running = True
        
        while self.running:
            try:
                # Connect to FlowLoom server
                if not await self.connect():
                    logger.error("Failed to connect, retrying in 5 seconds...")
                    await asyncio.sleep(5)
                    continue
                
                # Listen for messages
                while self.running and self.websocket:
                    try:
                        message = await asyncio.wait_for(
                            self.websocket.recv(), 
                            timeout=1.0
                        )
                        await self.handle_message(message)
                        
                    except asyncio.TimeoutError:
                        # Timeout is normal, just continue
                        continue
                    except websockets.exceptions.ConnectionClosed:
                        logger.warning("WebSocket connection closed")
                        break
                    except Exception as e:
                        logger.error(f"Error receiving message: {e}")
                        break
                        
            except Exception as e:
                logger.error(f"Connection error: {e}")
                
            finally:
                await self.disconnect()
                
            if self.running:
                logger.info("Reconnecting in 5 seconds...")
                await asyncio.sleep(5)
        
        logger.info("Bridge shutdown complete")

async def main():
    """Main entry point."""
    logger.info("üöÄ Starting FlowLoom Claude Bridge...")
    
    # Create and run the bridge
    bridge = FlowLoomClaudeBridge()
    
    try:
        await bridge.run()
    except KeyboardInterrupt:
        logger.info("Received keyboard interrupt")
    except Exception as e:
        logger.error(f"Bridge error: {e}")
    finally:
        logger.info("Bridge stopped")

if __name__ == "__main__":
    # Check if websockets is available
    try:
        import websockets
    except ImportError:
        print("‚ùå websockets module not found. Install with: pip install websockets")
        sys.exit(1)
    
    # Run the bridge
    asyncio.run(main())